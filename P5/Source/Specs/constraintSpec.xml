<?xml version="1.0" encoding="UTF-8"?>
<!--
Copyright TEI Consortium. 
Dual-licensed under CC-by and BSD2 licences 
See the file COPYING.txt for details
$Date$
$Id$
-->
<?xml-model href="https://jenkins.tei-c.org/job/TEIP5-dev/lastSuccessfulBuild/artifact/P5/release/xml/tei/odd/p5.nvdl" type="application/xml" schematypens="http://purl.oclc.org/dsdl/nvdl/ns/structure/1.0"?>
<elementSpec xmlns="http://www.tei-c.org/ns/1.0" xmlns:sch="http://purl.oclc.org/dsdl/schematron" module="tagdocs" ident="constraintSpec">
  <gloss versionDate="2009-06-10" xml:lang="en">constraint on schema</gloss>
  <desc versionDate="2017-06-24" xml:lang="en">contains a formal constraint, typically expressed in a rule-based schema language, to which a construct must conform in order to be considered valid<!--ebb: old description of 2009-06-10 was: "contains  a constraint, expressed in some formal syntax,
  which cannot be expressed in the structural content model"--></desc>
  <classes>
    <memberOf key="att.global"/>
    <memberOf key="att.identified"/>
    <memberOf key="att.typed"/>
    <memberOf key="model.oddDecl"/>
  </classes>
  <content>
    <sequence>
      <alternate minOccurs="0" maxOccurs="unbounded">
        <classRef key="model.identSynonyms"/>
        <classRef key="model.descLike"/>
      </alternate>
      <elementRef key="constraint" minOccurs="0" maxOccurs="1"/>
    </sequence>
  </content>
  <constraintSpec scheme="schematron" ident="empty-based-on-mode">
    <!-- 
         This constraint specification is much like the
         "child-constraint-based-on-mode" for <elementSpec>, which
         does something something similar (in that it is based on
         @mode), but not quite the same.
    -->
    <constraint>
      <sch:rule context="tei:constraintSpec[ @mode eq 'delete']">
        <sch:report test="child::*">This constraintSpec element has a mode= of "delete" even though it has child elements. Change the mode= to "add", "change", or "replace", or remove the child elements.</sch:report>
      </sch:rule>
      <sch:rule context="tei:constraintSpec[ @mode eq 'change']">
        <sch:assert test="child::*">This constraintSpec element has a mode= of "change", but does not have any child elements. Specify child elements, or change the mode= to "delete".</sch:assert>
      </sch:rule>
      <sch:rule context="tei:constraintSpec[ @mode = ('add','replace') ]">
        <sch:assert test="child::tei:constraint">This constraintSpec element has a mode= of "<sch:value-of select="@mode"/>", but does not have a child 'constraint' element. Use a child 'constraint' element or change the mode= to "delete" or "change".</sch:assert>
      </sch:rule>
    </constraint>
  </constraintSpec>
  <constraintSpec ident="sch_no_more" scheme="schematron">
    <desc xml:lang="en" versionDate="2018-07-06">Relationship between scheme attribute and contents: Schematron 1.x</desc>
    <constraint>
      <sch:report test="tei:constraint/sch1x:* and @scheme = ('isoschematron','schematron')">Rules
        in the Schematron 1.* language must be inside a constraintSpec
        with a value other than 'schematron' or 'isoschematron' on the
        scheme attribute</sch:report>
    </constraint>
  </constraintSpec>
  <constraintSpec ident="isosch" scheme="schematron">
    <desc xml:lang="en" versionDate="2018-07-06">Relationship between scheme attribute and contents: ISO Schematron</desc>
    <constraint>
      <sch:rule context="tei:constraintSpec[ @mode = ('add','replace') or not( @mode ) ]">
	<sch:report test="tei:constraint/sch:* and not( @scheme eq 'schematron')">Rules
          in the ISO Schematron language must be inside a constraintSpec
          with the value 'schematron' on the scheme attribute</sch:report>
      </sch:rule>
    </constraint>
  </constraintSpec>
  <constraintSpec ident="needrules" scheme="schematron">
    <constraint>
      <sch:rule context="tei:macroSpec/tei:constraintSpec[@scheme eq 'schematron']/tei:constraint">
        <sch:report test="sch:assert|sch:report">An ISO Schematron constraint specification for a macro should not
        have an 'assert' or 'report' element without a parent 'rule' element</sch:report>
      </sch:rule>
    </constraint>
  </constraintSpec>
  <constraintSpec ident="unique-constraintSpec-ident" scheme="schematron">
    <constraint>
      <sch:rule context="tei:constraintSpec[ @mode eq 'add' or not( @mode ) ]">
        <sch:let name="myIdent" value="normalize-space(@ident)"/>
        <sch:report test="preceding::tei:constraintSpec[ normalize-space(@ident) eq $myIdent ]">
        The @ident of 'constraintSpec' should be unique; this one (<sch:value-of select="$myIdent"/>) is the same as that of a previous 'constraintSpec'.
        </sch:report>
      </sch:rule>
    </constraint>
  </constraintSpec>
  <constraintSpec ident="context_for_constraint" scheme="schematron">
    <desc xml:lang="en" versionDate="2023-06-14">Any
    <gi>constraintSpec</gi> that <emph>not</emph> a child of
    <gi>schemaSpec</gi>, or a descendant of <gi>elementSpec</gi>, or
    inside a <gi>specGrp</gi> which is referred to from a child of an
    <gi>elementSpec</gi> should have a <att>context</att>
    attribute.</desc>
    <constraint>
      <!-- Fire on <constraintSpec scheme=schematron> that has no descendant @context -->
      <!-- Note that the “not( ancestor::teix:egXML )” predicate is
           not needed for normal TEI procerssing. It is only needed
           for the P5 build process itself, during which Schematron
           rules are run with the "tei:" prefix is bound to the
           Examples namespace, such that this rule would be fired
           inside <egXML>s when we don’t want that, because quite a
           few examples are contextless. -->
      <sch:rule context="tei:constraintSpec[ not( ancestor::teix:egXML ) ][ @scheme eq 'schematron' and not( .//@context ) ]">
        <!--
            Since <specGrp> can self-nest, it is possible we have more
            than 1 ancestor <specGrp>. We can keep track of them by
            @xml:id, because although @xml:id is not a required
            attribute on a <specGrp>, if there is no @xml:id it
            *cannot* be referenced from anywhere, let alone somewhere
            the Stylesheets can't figure out a context. So here assign
            all of the IDs of all of my ancestor <specGrp>s to a
            variable.

            It is probably not necesssary to normalize the whitespace
            around the @xml:id value, but use of normalize-space()
            makes it clear that we are dealing with strings here, not
            nodes.

            It is probably better in the general XPath 3+ case to use
            the simple mapping operator (‘!’) rather than the path
            operator (‘/’) before the normalize-space() step, but my
            current commandline Schematron processor (probatron)
            chokes on it. Maybe after I have switched to the
            poorly-named but well-executed SchXslt … —Syd
        -->
        <sch:let name="mySpecGrps" value="ancestor::tei:specGrp/@xml:id/normalize-space()"/>
                
        <!--
            Collect a sequence of the distinct targets of every
            <specGrpRef> in the current ODD document. Thus we end up
            with something like "#one subCust.odd#two #three".

            Note that there is no need to worry about multiple values
            in a specGrpRef/@target value, as the attribute is defined
            as having one and only one value (and is required).
        -->
        <sch:let name="allSpecGrpRefs"
                 value="distinct-values( //tei:specGrpRef/@target/normalize-space() )"/>

        <!--
            Prune the list down to those that are just shorthand
            pointer fragment identifiers, and then strip off their
            leading ‘#’ characters so the result is a sequence of
            unique IDs.
                    
            Thus we end up with something like "one three".  Yes, we
            are dropping references to external files that might
            somehow refer back to our <specGrp>. Such is life, we can
            only do so much. (And that is, at least in part, why we
            use role=warn.)
        -->
        <sch:let name="localSpecGrpRefs"
                 value="for $r in $allSpecGrpRefs return
                        if ( starts-with( $r,'#') )
                          then substring( $r, 2 )
                          else ''  "/>

        <!--
            If this <constraintSpec> (which remember, does not have a
            @context or we would not be in this <sch:rule>) is *not* a
            descdendant of an <elementSpec>, a <specGrp>, or the child
            of a <schemaSpec>, then there is no way the (current)
            Stylesheets can generate a context.
        -->
        <sch:assert test="  ancestor::tei:elementSpec
                          | parent::tei:schemaSpec
                          | ancestor::tei:specGrp"  role="warn">
          this constraintSpec <sch:value-of select="if (@ident) then
          concat('(&quot;', @ident,'&quot;)') else ''"/> does not have
          an explicit context specified (via a @context attribte), but
          software can probably not generate an appropriate context.
        </sch:assert>

        <!-- Now the hard part: check those in <specGrp>(s) -->
        <sch:report role="warn"
                    test="(: I am inside a specGrp, :)
                          ancestor::tei:specGrp
			  (: and I am not inside an elementSpec, :)
			  and not( ancestor::tei:elementSpec )
                          (: and there are one or more references to one or more of my
                             scpecGrp ancestors (of which there is probably only one) :)
                          and $mySpecGrps = $localSpecGrpRefs
                          and
                          (
                            (: each of the specGrps I am in … :)
                            every $id in $mySpecGrps satisfies
                            (
                              (: … is either not referred to by a local specGrpRef … :)
                              not( $localSpecGrpRefs = $id )
                              or
                              (
                                (: … OR it is not the case that every specGrpRef that
                                   does point to it … :)
                                not(
                                  every $tsgr in (: tsgr = this specification group reference :)
                                    //tei:specGrpRef[
                                      substring( normalize-space( @target ), 2 )
                                      =
                                      tokenize( $mySpecGrps )
                                      ]
                                    satisfies
                                      (: … is a descendant of elementSpec or
                                           is a child of schemaSpec. :)
                                        $tsgr/ancestor::tei:elementSpec
                                      | $tsgr/parent::tei:schemaSpec
                                      )
                                      (: Which is to say none of the &lt;specGrpRef>s that
                                         point to it are going to get an auto-generated
                                         context. Note that one might argue that we don’t
                                         really have to test for anyplace other than child
                                         of &lt;schemaSpec> because the only places in the
                                         tagdocs module in which a &lt;specGrpRef> is
                                         allowed is as a child of &lt;specGrp> or
                                         &lt;schemaSpec>. However, since (at the moment)
                                         it can also be a child of &lt;p>, &lt;emph>,
                                         or &lt;metaMark>, it is probably appropriate to
                                         check. :)
                              )
                            )
                          )">
        this constraintSpec <sch:value-of select="
        if (@ident)
        then concat('(&quot;', @ident,'&quot;)')
        else ''"/> has no @context, but is in a specGrp that has at
        least 1 reference to it that is not contextulizable.</sch:report>
      </sch:rule>
    </constraint>
  </constraintSpec>
  <attList>
    <attDef ident="scheme" usage="opt">
      <!-- Note:
	   Per "usage_based_on_mode", below,
  	   * usage=req iff mode=add or mode=replace
	   * usage=not allowed iff mode=change or mode=delete
      -->
      <desc versionDate="2009-06-10" xml:lang="en">supplies the name of the language in which the constraints
      are defined</desc>
      <datatype><dataRef key="teidata.enumerated"/></datatype>
      <constraintSpec scheme="schematron" ident="usage_based_on_mode">
	<constraint>
	  <sch:rule context="tei:constraintSpec[ @mode = ('add','replace')  or  not( @mode ) ]">
	    <sch:assert test="@scheme">The @scheme attribute of &lt;constraintSpec> is required when the @mode is <sch:value-of select="if (@mode) then concat('&quot;',@mode,'&quot;') else 'not specified'"/>.</sch:assert>
	  </sch:rule>
	</constraint>
      </constraintSpec>
      <valList type="semi">
        <valItem ident="schematron">
          <gloss versionDate="2016-09-27" xml:lang="en">ISO Schematron</gloss>
        </valItem>
      </valList>
      <remarks versionDate="2023-08-06" xml:lang="en">
        <p>These Guidelines no longer recommend, and the current TEI
        stylesheets no longer support, the use of Schematron 1.x
        within <gi>constraintSpec</gi>. Thus the value
        <val>schematron</val> is used to indicate that ISO Schematron
        is used within the <gi>constraintSpec</gi>.</p>
	<p>The <att>scheme</att> attribute is required when the value
	of <att>mode</att> is <val>add</val> or
	<val>replace</val>. The <att>scheme</att> attribute is
	permitted when the value of <att>mode</att> is
	<val>delete</val>, but these Guidelines make no reccomendation
	for what a processor should do if its value does not match
	that of the <gi>constraintSpec</gi> being deleted.</p>
      </remarks>
    </attDef>
    <attDef ident="type" mode="replace">
      <desc versionDate="2018-09-17" xml:lang="en">characterizes the
      <gi>constraintSpec</gi> element in some sense; used to indicate
      when a <gi>constraintSpec</gi> warns about a deprecated
      construct.</desc>
      <datatype><dataRef key="teidata.enumerated"/></datatype>
      <valList type="semi" mode="add">
        <valItem ident="deprecationWarning">
          <desc xml:lang="en" versionDate="2018-09-17">Indicates that
          this constraint specification warns that some other
          construct in the schema is deprecated.</desc>
        </valItem>
      </valList>
    </attDef>
  </attList>
  <exemplum xml:lang="en">
    <p>This constraint uses Schematron to enforce the presence of the
    <att>spanTo</att> attribute (which comes from an attribute class)
    on the <gi>addSpan</gi> element: </p>
    <egXML xmlns="http://www.tei-c.org/ns/Examples">
      <constraintSpec ident="demo-c1" scheme="schematron">
        <desc>Enforce the presence of the <att>spanTo</att> attribute</desc>
        <constraint>
          <sch:assert test="@spanTo">The spanTo= attribute of <sch:name/>
          is required.</sch:assert>
        </constraint>
      </constraintSpec>
    </egXML>
  </exemplum>
  <exemplum xml:lang="en">
    <p>This example demonstrates a constraint that may be added to the
    specification of <gi>figure</gi> to unsure that a textual
    explanation is present. It checks for the existence of one of the
    elements in which such an explanation is expected — it does not
    actually check that there is textual content in that element, nor
    that the textual explanation makes sense.</p>
    <egXML xmlns="http://www.tei-c.org/ns/Examples">
      <constraintSpec ident="demo-c2" scheme="schematron">
        <desc>Implement an accessibility rule which says that pictures
        should have textual explanations</desc>
        <constraint>
          <sch:report test="not(tei:figDesc or tei:head)"> You should
          provide information in a figure from which
          we can construct an alt attribute in HTML </sch:report>
        </constraint>
      </constraintSpec>
    </egXML>
  </exemplum>
  <exemplum xml:lang="en">
    <p>This constraint uses SPITBOL (a language which is not
    expressed in XML) to check whether the title and author are identical: </p>
    <egXML xmlns="http://www.tei-c.org/ns/Examples">
      <constraintSpec ident="author_ne_title" scheme="SPITBOL">
        <constraint> 
(output = leq(title,author)  "title and author cannot be the same")
        </constraint>
      </constraintSpec>
    </egXML>
  </exemplum>
  <remarks xml:lang="en" versionDate="2022-04-09">
    <p>A child <gi>constraint</gi> is required when the
    <att>mode</att> attribute has the value <val>replace</val> or
    <val>add</val> (or is not specified, as <val>add</val> is the
    default). No child elements are permitted when the <att>mode</att>
    attribute has the value <val>delete</val>. At least one child
    element is required when the <att>mode</att> attribute has the
    value <val>change</val>.</p>
  </remarks>
  <listRef>
    <ptr target="#TDTAG"/>
  </listRef>
</elementSpec>
